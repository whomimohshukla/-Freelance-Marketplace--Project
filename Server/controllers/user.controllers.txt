const User = require("../models/user.model");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcrypt");
const crypto = require("crypto");
const { OAuth2Client } = require("google-auth-library");
const speakeasy = require("speakeasy");
const qrcode = require("qrcode");
cons] starting `node index.js`
server is running on 3000
 connected to database
[nodemon] restarting due to changes...t { sendEmail } = require("../utils/emailServices");
const { validatePassword } = require("../utils/validators");
const { uploadToCloudinary } = require("../utils/cloudinary");

const userController = {
  // User Registration
  register: async (req, res) => {
    try {
      const {
        email,
        password,
        role,
        firstName,
        lastName,
        phoneNumber,
        location,
      } = req.body;

      // Check if user exists
      const existingUser = await User.findOne({ email, isDeleted: false });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: "Email is already registered",
        });
      }

      // Validate password strength
      if (!validatePassword(password)) {
        return res.status(400).json({
          success: false,
          message:
            "Password must be at least 8 characters long and contain uppercase, lowercase, number and special character",
        });
      }

      // Create verification token
      const verificationToken = crypto.randomBytes(32).toString("hex");

      // Create new user
      const user = new User({
        email,
        password,
        role,
        firstName,
        lastName,
        phoneNumber,
        location,
        resetPasswordToken: verificationToken,
        resetPasswordExpires: Date.now() + 24 * 60 * 60 * 1000, // 24 hours
      });

      await user.save();

      // Send verification email
      const verificationUrl = `${process.env.FRONTEND_URL}/verify-email/${verificationToken}`;
      await sendEmail({
        to: email,
        template: "verification",
        data: {
          name: `${firstName} ${lastName}`,
          verificationUrl,
        },
      });

      res.status(201).json({
        success: true,
        message: "Registration successful. Please verify your email.",
        data: {
          userId: user._id,
          email: user.email,
          role: user.role,
        },
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({
        success: false,
        message: "Registration failed. Please try again.",
      });
    }
  },

  // Email Verification
  verifyEmail: async (req, res) => {
    try {
      const { token } = req.params;

      const user = await User.findOne({
        resetPasswordToken: token,
        resetPasswordExpires: { $gt: Date.now() },
        isVerified: false,
      });

      if (!user) {
        return res.status(400).json({
          success: false,
          message: "Invalid or expired verification token",
        });
      }

      user.isVerified = true;
      user.resetPasswordToken = undefined;
      user.resetPasswordExpires = undefined;
      await user.save();

      res.json({
        success: true,
        message: "Email verified successfully",
      });
    } catch (error) {
      console.error("Email verification error:", error);
      res.status(500).json({
        success: false,
        message: "Email verification failed",
      });
    }
  },

  // User Login
  login: async (req, res) => {
    try {
      const { email, password } = req.body;

      // Find user
      const user = await User.findOne({ email, isDeleted: false });
      if (!user) {
        return res.status(401).json({
          success: false,
          message: "Invalid credentials",
        });
      }

      // Check if email is verified
      if (!user.isVerified) {
        return res.status(403).json({
          success: false,
          message: "Please verify your email first",
        });
      }

      // Verify password
      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) {
        return res.status(401).json({
          success: false,
          message: "Invalid credentials",
        });
      }

      // Check 2FA if enabled
      if (user.twoFactorEnabled) {
        return res.json({
          success: true,
          requires2FA: true,
          userId: user._id,
        });
      }

      // Generate JWT token
      const token = jwt.sign(
        { userId: user._id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
      );

      // Update last active
      user.lastActive = new Date();
      await user.save();

      res.json({
        success: true,
        token,
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
          avatar: user.avatar,
        },
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({
        success: false,
        message: "Login failed",
      });
    }
  },

  // Profile Management
  updateProfile: async (req, res) => {
    try {
      const userId = req.user.id;
      const { firstName, lastName, phoneNumber, location } = req.body;

      // Handle avatar upload
      let avatar;
      if (req.file) {
        const result = await uploadToCloudinary(req.file, "avatars");
        avatar = result.url;
      }

      const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
          firstName,
          lastName,
          phoneNumber,
          location,
          avatar: avatar || undefined,
        },
        { new: true, runValidators: true }
      ).select("-password");

      res.json({
        success: true,
        message: "Profile updated successfully",
        data: updatedUser,
      });
    } catch (error) {
      console.error("Profile update error:", error);
      res.status(500).json({
        success: false,
        message: "Profile update failed",
      });
    }
  },

  // 2FA Management
  setup2FA: async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await User.findById(userId);

      const secret = speakeasy.generateSecret({
        name: `SkillBridge:${user.email}`,
      });

      user.twoFactorSecret = secret.base32;
      await user.save();

      const qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url);

      res.json({
        success: true,
        data: {
          qrCode: qrCodeUrl,
          secret: secret.base32,
        },
      });
    } catch (error) {
      console.error("2FA setup error:", error);
      res.status(500).json({
        success: false,
        message: "2FA setup failed",
      });
    }
  },

  verify2FA: async (req, res) => {
    try {
      const { userId, token } = req.body;

      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      const verified = speakeasy.totp.verify({
        secret: user.twoFactorSecret,
        encoding: "base32",
        token,
      });

      if (!verified) {
        return res.status(401).json({
          success: false,
          message: "Invalid 2FA token",
        });
      }

      // Enable 2FA if not already enabled
      if (!user.twoFactorEnabled) {
        user.twoFactorEnabled = true;
        await user.save();
      }

      // Generate JWT token
      const jwtToken = jwt.sign(
        { userId: user._id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
      );

      res.json({
        success: true,
        token: jwtToken,
      });
    } catch (error) {
      console.error("2FA verification error:", error);
      res.status(500).json({
        success: false,
        message: "2FA verification failed",
      });
    }
  },

  // Password Reset
  forgotPassword: async (req, res) => {
    try {
      const { email } = req.body;

      const user = await User.findOne({ email, isDeleted: false });
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      const resetToken = crypto.randomBytes(32).toString("hex");
      user.resetPasswordToken = resetToken;
      user.resetPasswordExpires = Date.now() + 3600000; // 1 hour
      await user.save();

      const resetUrl = `${process.env.FRONTEND_URL}/reset-password/${resetToken}`;
      await sendEmail({
        to: email,
        template: "password-reset",
        data: {
          name: `${user.firstName} ${user.lastName}`,
          resetUrl,
        },
      });

      res.json({
        success: true,
        message: "Password reset email sent",
      });
    } catch (error) {
      console.error("Forgot password error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to send reset email",
      });
    }
  },

  resetPassword: async (req, res) => {
    try {
      const { token, newPassword } = req.body;

      const user = await User.findOne({
        resetPasswordToken: token,
        resetPasswordExpires: { $gt: Date.now() },
      });

      if (!user) {
        return res.status(400).json({
          success: false,
          message: "Invalid or expired reset token",
        });
      }

      // Validate new password
      if (!validatePassword(newPassword)) {
        return res.status(400).json({
          success: false,
          message: "Password must meet security requirements",
        });
      }

      user.password = newPassword;
      user.resetPasswordToken = undefined;
      user.resetPasswordExpires = undefined;
      await user.save();

      res.json({
        success: true,
        message: "Password reset successful",
      });
    } catch (error) {
      console.error("Reset password error:", error);
      res.status(500).json({
        success: false,
        message: "Password reset failed",
      });
    }
  },

  // Add these methods to the existing userController object

  // Get User Profile
  getProfile: async (req, res) => {
    try {
      const userId = req.params.id || req.user.id;

      const user = await User.findById(userId)
        .select(
          "-password -twoFactorSecret -resetPasswordToken -resetPasswordExpires"
        )
        .lean();

      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      // Get additional profile data based on role
      let profileData = {};
      if (user.role === "freelancer") {
        const freelancerProfile = await FreelancerProfile.findOne({
          user: userId,
        })
          .populate("skills")
          .populate("completedProjects")
          .populate("reviews")
          .lean();
        profileData = { ...freelancerProfile };
      } else if (user.role === "client") {
        const clientProfile = await ClientProfile.findOne({ user: userId })
          .populate("postedProjects")
          .populate("activeProjects")
          .lean();
        profileData = { ...clientProfile };
      }

      res.json({
        success: true,
        data: {
          ...user,
          profile: profileData,
        },
      });
    } catch (error) {
      console.error("Get profile error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch profile",
      });
    }
  },

  // Delete Account
  deleteAccount: async (req, res) => {
    try {
      const userId = req.user.id;
      const { password } = req.body;

      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      // Verify password before deletion
      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) {
        return res.status(401).json({
          success: false,
          message: "Invalid password",
        });
      }

      // Soft delete user
      user.isDeleted = true;
      user.email = `deleted_${user.email}_${Date.now()}`;
      await user.save();

      res.json({
        success: true,
        message: "Account deleted successfully",
      });
    } catch (error) {
      console.error("Delete account error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete account",
      });
    }
  },

  // Change Password
  changePassword: async (req, res) => {
    try {
      const userId = req.user.id;
      const { currentPassword, newPassword } = req.body;

      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      // Verify current password
      const isMatch = await bcrypt.compare(currentPassword, user.password);
      if (!isMatch) {
        return res.status(401).json({
          success: false,
          message: "Current password is incorrect",
        });
      }

      // Validate new password
      if (!validatePassword(newPassword)) {
        return res.status(400).json({
          success: false,
          message: "New password must meet security requirements",
        });
      }

      // Update password
      user.password = newPassword;
      await user.save();

      res.json({
        success: true,
        message: "Password changed successfully",
      });
    } catch (error) {
      console.error("Change password error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to change password",
      });
    }
  },

  // Social Login (Google)
  googleLogin: async (req, res) => {
    try {
      const { token } = req.body;
      const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

      const ticket = await client.verifyIdToken({
        idToken: token,
        audience: process.env.GOOGLE_CLIENT_ID,
      });

      const payload = ticket.getPayload();
      const email = payload.email;

      let user = await User.findOne({ email });

      if (!user) {
        // Create new user from Google data
        user = new User({
          email,
          firstName: payload.given_name,
          lastName: payload.family_name,
          isVerified: true,
          avatar: payload.picture,
          password: crypto.randomBytes(20).toString("hex"),
          role: "freelancer", // Default role, can be changed later
        });
        await user.save();
      }

      // Generate JWT token
      const jwtToken = jwt.sign(
        { userId: user._id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
      );

      res.json({
        success: true,
        token: jwtToken,
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
          avatar: user.avatar,
        },
      });
    } catch (error) {
      console.error("Google login error:", error);
      res.status(500).json({
        success: false,
        message: "Google login failed",
      });
    }
  },

  // Get User Stats
  getUserStats: async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await User.findById(userId);

      let stats = {
        projectsCount: 0,
        earningsTotal: 0,
        activeProjects: 0,
        completedProjects: 0,
        averageRating: 0,
        totalReviews: 0,
      };

      if (user.role === "freelancer") {
        const freelancerProfile = await FreelancerProfile.findOne({
          user: userId,
        });
        stats = {
          projectsCount: freelancerProfile.completedProjects.length,
          earningsTotal: freelancerProfile.earnings.total,
          activeProjects: freelancerProfile.activeProjects.length,
          completedProjects: freelancerProfile.completedProjects.length,
          averageRating: freelancerProfile.rating.average,
          totalReviews: freelancerProfile.rating.count,
        };
      } else if (user.role === "client") {
        const clientProfile = await ClientProfile.findOne({ user: userId });
        stats = {
          projectsPosted: clientProfile.postedProjects.length,
          activeProjects: clientProfile.activeProjects.length,
          completedProjects: clientProfile.completedProjects.length,
          totalSpent: clientProfile.payments.total,
          averageRating: clientProfile.rating.average,
          totalReviews: clientProfile.rating.count,
        };
      }

      res.json({
        success: true,
        data: stats,
      });
    } catch (error) {
      console.error("Get user stats error:", error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch user stats",
      });
    }
  },
};

module.exports = userController;
